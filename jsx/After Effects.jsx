// this is where you write whatever magic you want to happen.function magic() {  // app.project.item(1).layer(1).sourceText("asdf").trace();  // var txtFile = "/Users/vanessapyne/Desktop/asdfsdf.txt";  // try { var file = new File(txtFile); } catch (e) { alert('e: ', e)};  // var str = "My string of text";    app.project.items.addFolder("app.project :" + JSON.stringify(app.project));    app.project.items.addFolder("app :" + JSON.stringify(app));  // file.open("w"); // open file with write access  // file.writeln("First line of text");  // file.writeln("Second line of text " + str);  // file.write(str);  // file.close();  // return 'app.project';  // alert('magic!');  // return app.project;}// var magic = (function() {  // var printAppProject = function() {  //   alert('asdf', app.project);  // }//   return app.project;// };function GenerateCompName(location) {  if(location instanceof Project) {    return "CompGen " + app.project.items.length;  }  if(location instanceof CompItem) {    return "LayerGen " +location.numLayers;           }}function NestInComp(comp, thing){  return comp.layers.add(thing);}function BoundedRandom( minValue, maxValue ){    return minValue + Math.round(((maxValue - minValue) * Math.random()));}function MakeLayer(junkFolder, ioComp, minLayers, maxLayers, minDepth, maxDepth){    var layerType = BoundedRandom(0,1);    var newLayer = null;    if(maxDepth > minDepth) {       if(layerType == 0) {           var width = BoundedRandom(10, ioComp.width);           var height = BoundedRandom(10, ioComp.height);           var newLayer = ioComp.layers.addSolid([Math.random(), Math.random(), Math.random()], "Solid",  width, height, 1.0 );        } else if( layerType == 1) {            var newComp = MakeComp(junkFolder);            newLayer = NestInComp(ioComp, newComp);            var newMaxDepth = BoundedRandom(minDepth, maxDepth - 1);            FillOutComp( junkFolder,  newComp, minLayers, maxLayers, minDepth, newMaxDepth)        }                newLayer.transform.position.expression = "transform.position.wiggle(" + BoundedRandom(1,7) +"," + BoundedRandom(2,200) + ", 1);";            newLayer.transform.opacity.setValue(50);            newLayer.transform.opacity.expression = "transform.opacity.wiggle(4, 50);";        }}function FillOutComp(junkFolder, ioComp, minLayers, maxLayers, minDepth, maxDepth){    // a comp can have from min to maxLayer. Use random to choose how many    var numLayersToGen = BoundedRandom(minLayers, maxLayers);    for( var i = 0; i < numLayersToGen; i++) {       MakeLayer(junkFolder, ioComp, minLayers, maxLayers, minDepth, maxDepth );    }    return ioComp;}function MakeComp(junkFolder){   return junkFolder.items.addComp(GenerateCompName(app.project), 1000, 500, 1.0, 30, 30 );}function Generate() {  var cache = [],       theKey = 'theKey',       theValue = 'theValue';    // app.project.items.addComp("comp ::: " + app.project.activeItem.bgColor );  // app.project.items.addComp("comp ::: " + JSON.stringify(app.project.activeItem.bgColor) );    app.project.items.addComp("comp ::: " + JSON.stringify(app.project.activeItem, function(key, value) {    // alert('key--', key);    // alert('value--', value);    // theKey = typeof key === 'string' ? key : theKey;    // theValue = typeof value === 'string' ? value : theValue;    // app.project.items.addFolder("key:::"+theKey);    // app.project.items.addFolder("value:::"+theValue);    // if (typeof value === 'array') { return undefined };    // app.project.items.addFolder('this:' + (this));    if (value === null) {      app.project.items.addFolder('value' + 'null');    }    app.project.items.addFolder('typeof value-' + (typeof value));    if ( (typeof value === 'object') && (value !== null) ) {      if ( cache.indexOf(value) !== -1 ) {        return;      }      // key to `activeItem AVLayer` a number... this messes up stringify      if ( typeof key === 'number') {        // key =         app.project.items.addFolder('eh?'+value.name);        return;      }      cache.push(value);      // if (cache.length >= 100) {      //   return;      // }    }    // app.project.items.addFolder('v-');    // if ( (value !== undefined) && (value !== null) ) {      return value;    // } else {    //   return 'derp';    // }  }), 1000, 500, 1.0, 30, 24 );    cache = null;  // app.project.items.addFolder("key:::"+theKey);  // app.project.items.addFolder("value:::"+theValue);}  // var derr = try {JSON.stringify(app.project.activeItem} catch(e) {document.write('e::::',e)}  // app.project.items.addFolder("activeItem:" + derr);  // app.project.items.addComp("comp ::: "+app.project.items.list, 1000, 500, 1.0, 30, 24 );  // try {app.project.items.addFolder("Project ::: " + Project);  //   } catch(e) {  //     alert('nope');  //   }  // try {app.project.items.addFolder("CompItem ::: " + CompItem);  //   } catch(e) {  //     alert('nope');  //   }  // app.project.items.addFolder("Junk :" + JSON.stringify(app.project));  // var test = app.project.items.addFolder("Junk :" + __adobe_cep__);  // var junkFolder = app.project.items.addFolder("Junk " + app.project.items.length);  // var debugComp =  app.project.items.addComp("app.project " + app.project.items.length, 1000, 500, 1.0, 30, 30 );  // FillOutComp(junkFolder, debugComp,    //                                                     1 ,  // minLayers  //                                                     10, // maxLayers  //                                                     3,   //minDepth  //                                                     5); // maxDepth$._ext = {    generateComplexComp : function()    {    // alert("done");    // alert("Creating dummy project, app version=" + app.version);    Generate();		alert(" done asdfadsfasdasfsd");    // magic();    },    magic_ext : function() {      // var _this = this;      // var file = "~/Desktop/this.txt";      // var f = new File([""], file);      // f.open("w");      // f.writeln("------3q45q34543----");      // // f.writeln(JSON.stringify(_this));      // f.close();      magic();      alert('this', this);    }};